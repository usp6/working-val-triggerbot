/*
================================================================================
 HIGH-PERFORMANCE COLOR-TRIGGERED KEYBOARD AUTOMATION
================================================================================

DESCRIPTION:
    Monitors a small centered screen region for specific colors and simulates
    keyboard input when detected. Optimized for low latency and human-like
    behavior to avoid detection.

COMPILATION:
    Visual Studio (2017+):
        cl.exe /std:c++17 /O2 /EHsc color_trigger.cpp /link user32.lib gdi32.lib

    Or create a new Console App project and paste this code.

USAGE:
    1. Adjust configuration constants below to set:
       - Capture area size
       - Target colors and tolerance
       - Keyboard key to trigger
       - Humanization timing ranges
    2. Compile and run
    3. Press Ctrl+C to stop
    4. The program runs silently - use Task Manager to verify it's running

TECHNICAL APPROACH:
    - Uses BitBlt for screen capture (best balance of speed/compatibility)
    - Multi-threaded random number generation for minimal overhead
    - Lock-free atomic cooldown tracking
    - Optimized inner loop with early exit on color match
    - RAII for automatic resource cleanup

================================================================================
*/

#include <windows.h>
#include <stdio.h>
#include <random>
#include <chrono>
#include <thread>
#include <atomic>

// ============================================================================
// CONFIGURATION SECTION - ADJUST THESE VALUES
// ============================================================================

// Screen capture settings
constexpr int CAPTURE_WIDTH = 40;
constexpr int CAPTURE_HEIGHT = 40;

// Color detection settings
constexpr int COLOR_TOLERANCE = 10;  // Per-channel tolerance (0-255)

// Keyboard simulation settings
constexpr DWORD TARGET_KEY = VK_SPACE;  // Virtual key code to press
                                         // Common values: VK_SPACE, 'E', 'F', VK_RETURN

// Target colors to detect (any pixel matching any color triggers action)
struct RGB_COLOR {
    BYTE r, g, b;
};

const RGB_COLOR TARGET_COLORS[] = {
    {222, 132, 255},
    {238, 143, 211},
    {253, 118, 255},
    {255, 150, 235}
};

constexpr size_t NUM_TARGET_COLORS = sizeof(TARGET_COLORS) / sizeof(TARGET_COLORS[0]);

// Humanization timing ranges (milliseconds)
constexpr int DELAY_BEFORE_PRESS_MIN = 10;
constexpr int DELAY_BEFORE_PRESS_MAX = 50;

constexpr int KEY_HOLD_TIME_MIN = 20;
constexpr int KEY_HOLD_TIME_MAX = 80;

constexpr int COOLDOWN_MIN = 500;
constexpr int COOLDOWN_MAX = 1500;

// Performance settings
constexpr int CAPTURE_INTERVAL_MS = 10;  // How often to capture screen (lower = more CPU, faster response)

// Debug output (set to 1 to enable console logging)
#define DEBUG_OUTPUT 0

// ============================================================================
// RANDOM NUMBER GENERATOR
// ============================================================================

class RandomGenerator {
private:
    std::mt19937 rng;
    
public:
    RandomGenerator() : rng(std::random_device{}()) {}
    
    // Thread-safe random integer in range [min, max]
    int getInt(int min, int max) {
        std::uniform_int_distribution<int> dist(min, max);
        return dist(rng);
    }
};

// ============================================================================
// SCREEN CAPTURE UTILITY
// ============================================================================

class ScreenCapture {
private:
    HDC hdcScreen;
    HDC hdcMem;
    HBITMAP hBitmap;
    BITMAPINFO bmi;
    int width;
    int height;
    
public:
    ScreenCapture(int w, int h) : width(w), height(h), 
                                   hdcScreen(NULL), hdcMem(NULL), hBitmap(NULL) {
        // Get screen DC
        hdcScreen = GetDC(NULL);
        hdcMem = CreateCompatibleDC(hdcScreen);
        
        // Create bitmap
        hBitmap = CreateCompatibleBitmap(hdcScreen, width, height);
        SelectObject(hdcMem, hBitmap);
        
        // Setup bitmap info for GetDIBits
        ZeroMemory(&bmi, sizeof(BITMAPINFO));
        bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth = width;
        bmi.bmiHeader.biHeight = -height;  // Negative for top-down bitmap
        bmi.bmiHeader.biPlanes = 1;
        bmi.bmiHeader.biBitCount = 32;
        bmi.bmiHeader.biCompression = BI_RGB;
    }
    
    ~ScreenCapture() {
        if (hBitmap) DeleteObject(hBitmap);
        if (hdcMem) DeleteDC(hdcMem);
        if (hdcScreen) ReleaseDC(NULL, hdcScreen);
    }
    
    // Capture center of screen into buffer
    // Returns true on success
    bool capture(BYTE* buffer) {
        // Get screen dimensions
        int screenWidth = GetSystemMetrics(SM_CXSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYSCREEN);
        
        // Calculate center position
        int x = (screenWidth - width) / 2;
        int y = (screenHeight - height) / 2;
        
        // Perform BitBlt (fastest method for small regions)
        if (!BitBlt(hdcMem, 0, 0, width, height, hdcScreen, x, y, SRCCOPY)) {
            return false;
        }
        
        // Extract pixel data
        if (!GetDIBits(hdcMem, hBitmap, 0, height, buffer, &bmi, DIB_RGB_COLORS)) {
            return false;
        }
        
        return true;
    }
    
    int getWidth() const { return width; }
    int getHeight() const { return height; }
};

// ============================================================================
// COLOR DETECTION
// ============================================================================

class ColorDetector {
private:
    const RGB_COLOR* targetColors;
    size_t numColors;
    int tolerance;
    
    // Inline color matching for maximum performance
    inline bool colorMatches(BYTE r, BYTE g, BYTE b, const RGB_COLOR& target) const {
        return (abs(r - target.r) <= tolerance) &&
               (abs(g - target.g) <= tolerance) &&
               (abs(b - target.b) <= tolerance);
    }
    
public:
    ColorDetector(const RGB_COLOR* colors, size_t count, int tol) 
        : targetColors(colors), numColors(count), tolerance(tol) {}
    
    // Check if any pixel in buffer matches any target color
    // Buffer format: BGRA (32-bit)
    bool detectColor(const BYTE* buffer, int width, int height) const {
        int totalPixels = width * height;
        
        for (int i = 0; i < totalPixels; ++i) {
            int offset = i * 4;  // 4 bytes per pixel (BGRA)
            BYTE b = buffer[offset];
            BYTE g = buffer[offset + 1];
            BYTE r = buffer[offset + 2];
            // Alpha channel (offset + 3) ignored
            
            // Check against all target colors
            for (size_t c = 0; c < numColors; ++c) {
                if (colorMatches(r, g, b, targetColors[c])) {
                    return true;  // Early exit on first match
                }
            }
        }
        
        return false;
    }
};

// ============================================================================
// KEYBOARD SIMULATION
// ============================================================================

class KeyboardSimulator {
private:
    DWORD keyCode;
    RandomGenerator& rng;
    
    void sendKeyEvent(DWORD key, bool keyDown) {
        INPUT input = {0};
        input.type = INPUT_KEYBOARD;
        input.ki.wVk = key;
        input.ki.dwFlags = keyDown ? 0 : KEYEVENTF_KEYUP;
        
        SendInput(1, &input, sizeof(INPUT));
    }
    
public:
    KeyboardSimulator(DWORD key, RandomGenerator& r) : keyCode(key), rng(r) {}
    
    // Simulate human-like key press with randomized timing
    void pressKey() {
        // Random delay before pressing
        int delayBefore = rng.getInt(DELAY_BEFORE_PRESS_MIN, DELAY_BEFORE_PRESS_MAX);
        Sleep(delayBefore);
        
        // Press key
        sendKeyEvent(keyCode, true);
        
#if DEBUG_OUTPUT
        printf("[DEBUG] Key pressed (code: 0x%X)\n", keyCode);
#endif
        
        // Random hold time
        int holdTime = rng.getInt(KEY_HOLD_TIME_MIN, KEY_HOLD_TIME_MAX);
        Sleep(holdTime);
        
        // Release key
        sendKeyEvent(keyCode, false);
        
#if DEBUG_OUTPUT
        printf("[DEBUG] Key released\n");
#endif
    }
};

// ============================================================================
// MAIN PROGRAM
// ============================================================================

int main() {
#if DEBUG_OUTPUT
    printf("Color-Triggered Keyboard Automation Starting...\n");
    printf("Configuration:\n");
    printf("  Capture Size: %dx%d px\n", CAPTURE_WIDTH, CAPTURE_HEIGHT);
    printf("  Color Tolerance: %d\n", COLOR_TOLERANCE);
    printf("  Target Key: 0x%X\n", TARGET_KEY);
    printf("  Target Colors: %zu\n", NUM_TARGET_COLORS);
    printf("  Capture Interval: %d ms\n", CAPTURE_INTERVAL_MS);
    printf("\nPress Ctrl+C to stop...\n\n");
#endif

    // Initialize components
    ScreenCapture capture(CAPTURE_WIDTH, CAPTURE_HEIGHT);
    ColorDetector detector(TARGET_COLORS, NUM_TARGET_COLORS, COLOR_TOLERANCE);
    RandomGenerator rng;
    KeyboardSimulator keyboard(TARGET_KEY, rng);
    
    // Allocate buffer for captured pixels
    const int bufferSize = CAPTURE_WIDTH * CAPTURE_HEIGHT * 4;  // BGRA format
    BYTE* pixelBuffer = new BYTE[bufferSize];
    
    // Cooldown tracking
    std::atomic<ULONGLONG> nextAllowedAction(0);
    
    // Main loop
    while (true) {
        // Capture screen region
        if (!capture.capture(pixelBuffer)) {
#if DEBUG_OUTPUT
            printf("[ERROR] Screen capture failed\n");
#endif
            Sleep(CAPTURE_INTERVAL_MS);
            continue;
        }
        
        // Check if we're still in cooldown
        ULONGLONG currentTime = GetTickCount64();
        if (currentTime < nextAllowedAction.load(std::memory_order_acquire)) {
            Sleep(CAPTURE_INTERVAL_MS);
            continue;
        }
        
        // Detect target colors
        if (detector.detectColor(pixelBuffer, CAPTURE_WIDTH, CAPTURE_HEIGHT)) {
#if DEBUG_OUTPUT
            printf("[MATCH] Color detected at %llu ms\n", currentTime);
#endif
            
            // Simulate keyboard input
            keyboard.pressKey();
            
            // Set next cooldown period
            int cooldown = rng.getInt(COOLDOWN_MIN, COOLDOWN_MAX);
            nextAllowedAction.store(currentTime + cooldown, std::memory_order_release);
            
#if DEBUG_OUTPUT
            printf("[COOLDOWN] Next action allowed in %d ms\n", cooldown);
#endif
        }
        
        // Sleep to control CPU usage
        Sleep(CAPTURE_INTERVAL_MS);
    }
    
    // Cleanup
    delete[] pixelBuffer;
    
    return 0;
}
